## 시간 복잡도
- 알고리즘 실행 시간
- 입력값과 연산 수행 시간의 상관관계를 나타내는 척도

## 빅오 표기법
- 최악의 경우를 고려하므로, 프로그램이 실행되는 과정에서 소요되는 최악의 시간까지 고려
 <center><img src="https://user-images.githubusercontent.com/42835988/140283068-f89407f8-8d6b-4a82-ab1d-efbc7aa15738.png" width="450" height="320"></center>

> ### O(1) < O(log n) < O(n) < O(n * log n) < O(n²) < O(n³) < O(2^n) < O(n!)

1. O(1) 
 > 입력 자료의 수(n)에 관계없이 일정한 실행 시간을 갖는 알고리즘(Constant Time) - 예시 : 배열에서 특정 인덱스 찾기, 해시테이블 추가

2. O(log n) 
 > 초반엔 빠르지만 후반부 갈수록 시간이 증가함 - 예시 : 이진 탐색

3. O(n) 
> 입력 자료의 크기가 N일경우 N 번만큼의 수행시간을 가진다.(linear) - 예시 : 연결 리스트 순회, 최대값찾기

4. O(n log n) 
> 선형 로그형, 데이터의 수가 2배로 늘 때, 연산횟수가 2배 조금 넘게 증가한다. - 예시 : 퀵 정렬, 병합정렬 등

5. O(n^2) 
> 주로 2중 for loop를 사용하여 조합가능한 모든 쌍을 대상으로 하는 경우가 전형적(quadratic) - 예시 : 버블 정렬,삽입 정렬

6. O(n^3) 
> 3차형(cubic)

7. O(2^n) 
> 지수형 빅오, '지수적증가'는 무서운 연산횟수 증가를 야기한다. - 예시 :피보나치수열

8. O(c^n) 
> 최악의 시간 복잡도 - exponential - 예시 : recursion

9. O(n!) 
> 계승(factorial)

## 시간복잡도를 구하는 요령
- 하나의 루프를 사용하여 단일 요소 집합을 반복 하는 경우 : O (n)
- 컬렉션의 절반 이상 을 반복 하는 경우 : O (n / 2) -> O (n)
- 두 개의 다른 루프를 사용하여 두 개의 개별 콜렉션을 반복 할 경우 : O (n + m) -> O (n)
- 두 개의 중첩 루프를 사용하여 단일 컬렉션을 반복하는 경우 : O (n²)
- 두 개의 중첩 루프를 사용하여 두 개의 다른 콜렉션을 반복 할 경우 : O (n * m) -> O (n²)
- 컬렉션 정렬을 사용하는 경우 : O(n*log(n))

## 정렬 알고리즘 비교
<img src="https://user-images.githubusercontent.com/42835988/140286418-51c3e201-cc11-41c3-99af-1687ad046759.png" width="480" height="500">

## 자료구조 비교
<img src="https://user-images.githubusercontent.com/42835988/140286460-0514278a-a948-4333-8f27-574af38f7980.png" width="510" height="530">
