# 68646 - 풍선 터트리기
# a의 수가 -10억 ~ 10억.. 시간복잡도는 O(n)이어야할 것 같다

"""
핵심 아이디어 - ** 끝까지 남을 수 있는 풍선의 조건은 자신을 기준으로 양쪽의 최솟값 중 하나라도 자신보다 크면 된다는 것
다시 말해, 자기 자신의 위치를 x라고 한다면, 인덱스 구간 [0, x]와 [x, end]에서 a[x]보다 작은 풍선을 최소 1번 이상은 제거해야하는데,
양쪽 모두에 a[x]보다 번호가 더 작은 풍선이 있다면 인접한 두 풍선중에서 번호가 더 작은 풍선을 터뜨리는 행위를 최소 2번 이상 해야하므로 불가
"""

# min 함수를 이용하면 시간초과, 메모이제이션을 이용해서 풀어야한다.

def solution(a):
    if len(a) == 1 : # a의 길이가 1이면 풍선 하나
        return 1

    answer = 2 # 양 끝의 풍선은 고정적으로 터뜨리지 않아도 된다.

    # 양 끝 최소값 쌓기
    left = [a[0]] # 첫 인덱스의 값을 left에 리스트(배열) 형태로 넣기
    right = [a[-1]] # 가장 끝 인덱스 right에 리스트(배열) 형태로 넣기

    for i in range(1, len(a)): # 양끝은 터뜨리지 않아도 되므로 1부터 시작
        if a[i] < left[-1]: # 좌측부터 시작하는 최솟값이 갱신되는 경우 (가장 마지막에 있는 값 비교)
            left.append(a[i]) # 갱신
        else:
            left.append(left[-1]) # 이전에 있는 값 그대로 넣기

        if a[len(a)-1-i] < right[-1]: # 우측부터 시작하는 최솟값이 갱신되는 경우
            right.append(a[len(a)-1-i]) #갱신
        else:
            right.append(right[-1]) # 이전에 있는 값 그대로 넣기

    right.reverse() # a[i] 오른쪽 출발, 최솟값을 추가한 값은 reverse하여 left와 동일한 순서로 바꿔준다.

    for i in range(1, len(a)-1):
        # left, right에 저장된 최솟값들과 a[i] 배열을 비교하고, 왼쪽 혹은 오른쪽에 번호가 더 작은 풍선이 있는 경우에만
        # answer 값을 1 추가한다.
        if left[i-1] > a[i] or right[i+1] > a[i] :
            answer += 1

    return answer